## 背景

  博主在工作中遇到一个新需求，在预览表格时，当某个单元格中文本或者数字内容过长时，就会出现该单元格不能将内容完全展示，这是由于单元格内容的字体设置都是固定的值，当字体内容过长时，就会超出了对应单元格的宽度，因此就会展示不全，所以需要将每个单元格的字体应该是根据单元格内容长度来自适应调整的形式，这样就能完全展示所有内容，博主这里的自适应实现是基于二分查找算法来实现。

---

## 1. 二分查找算法基础

### 1.1 经典二分查找

二分查找（Binary Search）是一种在**有序数组**中查找特定元素的高效算法。

**基本思想**：
- 每次比较中间元素，排除一半的搜索空间
- 时间复杂度：O(log n)
- 空间复杂度：O(1)

**经典应用场景**：

```cpp
// 在有序数组中查找目标值
int binarySearch(int arr[], int target, int left, int right) {
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) {
            return mid;  // 找到目标
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1;  // 目标在左半部分
        }
    }
    return -1;  // 未找到
}
```

### 1.2 二分查找的变体

在字体自适应场景中，使用的是**连续域上的二分查找**（也称为二分答案）：

**与经典二分查找的区别**：

| 特性 | 经典二分查找 | 连续域二分查找 |
|------|------------|---------------|
| 搜索空间 | 离散（数组索引） | 连续（实数范围） |
| 目标 | 精确匹配某个值 | 找到满足条件的最优值 |
| 停止条件 | 找到目标或遍历完 | 精度达到要求 |
| 结果 | 目标的索引 | 最优解的近似值 |

**应用场景**：
- 求解方程的根（数值分析）
- 最优化问题（寻找最大/最小值）
- **字体大小调整**（寻找最大适合的字体）

---

## 2. 字体自适应问题

以下是在项目中使用二分查找方法找到最适配字体大小的一个简单思路：

给定：
- 单元格文本内容：`content`
- 可用矩形区域：`rect`（宽度 W，高度 H）
- 原始字体大小：`originalSize`
- 最小字体限制：`MIN_FONT_SIZE`

求解：
- 最大字体大小 `fontSize`，使得文本在该字体下完全适合矩形区域

**数学表达**：
```
最大化：fontSize
约束条件：
    textWidth(fontSize) ≤ W
    textHeight(fontSize) ≤ H
    MIN_FONT_SIZE ≤ fontSize ≤ originalSize
```

字体大小实际上是与文本边界呈**单调关系**

```
fontSize ↑  ⟹  textWidth ↑  且  textHeight ↑
fontSize ↓  ⟹  textWidth ↓  且  textHeight ↓
```

这种单调性是应用二分查找的**充要条件**。

**函数模型**：

```cpp
bool fits(double fontSize) {
    // 返回：该字体大小下文本是否适合单元格
    double width = calculateTextWidth(fontSize, content);
    double height = calculateTextHeight(fontSize, content);
    return (width <= W && height <= H);
}
```

`fits(fontSize)` 具有以下性质：
- 当 `fontSize` 很小时，`fits(fontSize) = true`
- 当 `fontSize` 很大时，`fits(fontSize) = false`
- 存在临界点 `fontSize*`，使得：
  - `fontSize < fontSize*` 时，`fits(fontSize) = true`
  - `fontSize > fontSize*` 时，`fits(fontSize) = false`

**因此在项目中实际要做的就是找到最大的 `fontSize`，使得 `fits(fontSize) = true`，调整单元格字体尺寸使得可以完美适配展示内容。**

```
[MIN_FONT_SIZE, originalSize]
     ↓
[4.0pt, 例如 10.0pt]
```

```
字体大小 →  4.0   5.0   6.0   7.0   8.0   9.0   10.0
fits()   →  ✓     ✓     ✓     ✓     ✗     ✗    ✗
                              ↑
                           临界点
```

找的是最后一个 `✓` 的位置（最大可行解）。

---

## 3. 算法思路

```
开始
  ↓
初始化搜索范围
  minSize = 4.0pt
  maxSize = originalSize
  bestSize = 4.0pt
  ↓
maxSize - minSize > 0.2 且 iterations < 25 ?
  ↓ 是                                      ↓ 否
计算中点                                返回 bestSize
  midSize = (minSize + maxSize) / 2
  ↓
设置字体大小为 midSize
  ↓
测量文本边界
  testBounds = measure(content, midSize)
  ↓
检查是否适合
  fits = (testBounds.width * 1.005 ≤ rect.width) &&
         (testBounds.height * 1.005 ≤ rect.height)
  ↓
    fits == true ?
    ↓ 是              ↓ 否
bestSize = midSize   (不更新bestSize)
minSize = midSize    maxSize = midSize
    ↓                    ↓
    └────────┬───────────┘
             ↓
    iterations++
             ↓
    回到循环判断
```

**二分查找算法的原理实际上就是通过每一次迭代筛除一半的范围，通过逐步缩小范围找到最佳值。**

```cpp
if (fits) {
    bestSize = midSize;   // ← 关键：记录当前可行解
    minSize = midSize;    // 尝试更大的字体
} else {
    maxSize = midSize;    // 尝试更小的字体
}
```

| 情况 | fits | 操作 | 搜索空间变化 |
|------|------|------|-------------|
| 文本适合 | true | `minSize = midSize` | 舍弃左半部分 `[minSize, midSize]` |
| 文本溢出 | false | `maxSize = midSize` | 舍弃右半部分 `[midSize, maxSize]` |

**为什么更新 `bestSize`**：
- 只在 `fits == true` 时更新
- 保证 `bestSize` 始终是一个**可行解**
- 即使后续迭代失败，也能返回有效值

---

## 4. 实际场景的复现

  以下是在实际调试过程中的一个场景，在实际场景中对于超界的单元格内容一般在五到六次迭代之后就能调整到一个最适配的字体值。

### 4.1 示例场景

**输入数据**：

- 内容：`"1,222,222,222,222,256.00"` (22个字符)
- 原始字体：`8.0pt`
- 单元格宽度：`92.6px`
- 单元格高度：`28.6px`
- MIN_FONT_SIZE：`4.0pt`
- SAFETY_MARGIN：`1.005`
- TOLERANCE：`0.2pt`

### 4.2 初始状态

```
minSize = 4.0pt
maxSize = 8.0pt
bestSize = 4.0pt
区间长度 = 8.0 - 4.0 = 4.0pt
```

**初始溢出检测**：
```
fontSize = 8.0pt
textWidth = 143.0px  (假设值)
143.0 * 1.005 = 143.7px > 92.6px  ← 溢出！需要调整
```

### 4.3 迭代过程详解

#### 第1次迭代

```
minSize = 4.0pt, maxSize = 8.0pt
midSize = (4.0 + 8.0) / 2 = 6.0pt

测试 fontSize = 6.0pt:
  textWidth ≈ 143.0 × (6.0/8.0) = 107.25px
  textHeight ≈ 11.0 × (6.0/8.0) = 8.25px

检查适合性:
  107.25 * 1.005 = 107.79px > 92.6px  ← 不适合

更新: maxSize = 6.0pt
新区间: [4.0, 6.0]
```

#### 第2次迭代

```
minSize = 4.0pt, maxSize = 6.0pt
midSize = (4.0 + 6.0) / 2 = 5.0pt

测试 fontSize = 5.0pt:
  textWidth ≈ 143.0 × (5.0/8.0) = 89.38px
  textHeight ≈ 11.0 × (5.0/8.0) = 6.88px

检查适合性:
  89.38 * 1.005 = 89.83px < 92.6px  ← 适合！
  6.88 * 1.005 = 6.91px < 28.6px   ← 适合！

更新: bestSize = 5.0pt, minSize = 5.0pt
新区间: [5.0, 6.0]
```

#### 第3次迭代

```
minSize = 5.0pt, maxSize = 6.0pt
midSize = (5.0 + 6.0) / 2 = 5.5pt

测试 fontSize = 5.5pt:
  textWidth ≈ 143.0 × (5.5/8.0) = 98.31px
  textHeight ≈ 11.0 × (5.5/8.0) = 7.56px

检查适合性:
  98.31 * 1.005 = 98.80px > 92.6px  ← 不适合

更新: maxSize = 5.5pt
新区间: [5.0, 5.5]
```

#### 第4次迭代

```
minSize = 5.0pt, maxSize = 5.5pt
midSize = (5.0 + 5.5) / 2 = 5.25pt

测试 fontSize = 5.25pt:
  textWidth ≈ 143.0 × (5.25/8.0) = 93.84px
  textHeight ≈ 11.0 × (5.25/8.0) = 7.22px

检查适合性:
  93.84 * 1.005 = 94.31px > 92.6px  ← 不适合

更新: maxSize = 5.25pt
新区间: [5.0, 5.25]
```

#### 第5次迭代

```
minSize = 5.0pt, maxSize = 5.25pt
midSize = (5.0 + 5.25) / 2 = 5.125pt

测试 fontSize = 5.125pt:
  textWidth ≈ 143.0 × (5.125/8.0) = 91.61px
  textHeight ≈ 11.0 × (5.125/8.0) = 7.05px

检查适合性:
  91.61 * 1.005 = 92.07px < 92.6px  ← 适合！
  7.05 * 1.005 = 7.08px < 28.6px   ← 适合！

更新: bestSize = 5.125pt, minSize = 5.125pt
新区间: [5.125, 5.25]
```

#### 第6次迭代

```
minSize = 5.125pt, maxSize = 5.25pt
区间长度 = 5.25 - 5.125 = 0.125pt < 0.2pt  ← 达到精度要求

停止迭代！
返回 bestSize = 5.125pt
```

**最终结果**：`5.125pt`

```
实际文本宽度 = 143.0 × (5.125/8.0) = 91.61px
安全边距后 = 91.61 × 1.005 = 92.07px < 92.6px  ✓

空间利用率 = 92.07 / 92.6 = 99.43%  ✓
```

经过六次迭代基本就可以获取到一个最佳的字体值。
---

## 9. 性能分析

### 9.1 时间复杂度

**单个单元格**：
```
T(n) = O(log n × C)
```
其中：
- `n`：搜索空间大小（字体范围）
- `C`：单次字体度量时间（常数）

**实际测量**：
```
单次字体度量: ~0.01ms
平均迭代次数: 10次
单个单元格处理: ~0.1ms
```

**1000个单元格报表**：
```
需要调整的单元格: 100个（10%）
总时间: 100 × 0.1ms = 10ms
占总渲染时间: < 5%
```

### 9.2 空间复杂度

```
S(n) = O(1)
```

**内存使用**：
- 固定变量：`minSize`, `maxSize`, `bestSize`, `iterations` 等
- 无递归，无动态分配
- 临时对象：`QFont`, `QRectF`（栈上分配）

**估计**：每个单元格处理约 100 bytes 栈空间。





  以上就是对于二分查找算法的实现场景，在这种范围查询的场景下使用二分查找法还是可以达到一个比较好的效果的。





